import threading
import time
import queue
import serial  # pyserial
import serial.tools.list_ports
from File_managers import marlin_config_manager
from File_managers import config_manager
from Pozitioner_and_Communicater.gcode_presets import MARLIN_COMMAND_MAP

class GCodeControl:
    def __init__(self, lock=None):
        self.lock = lock
        self.ser = None
        self.lock = lock
        self.connected = False
        self.label_status = None  # ezt k√≠v√ºlr≈ël lehet be√°ll√≠tani (pl. a GUI-b√≥l)
        self.log_widget = None  # Ezt majd k√≠v√ºlr≈ël be√°ll√≠tod a MainWindow-ban


        # Parancs sorok minden sz√°lhoz
        self.x_motor_queue = queue.Queue()
        self.y_motor_queue = queue.Queue()
        self.aux_queue = queue.Queue()
        self.control_queue = queue.Queue()

        self.running = True

    def __del__(self):
        print("[INFO] GCodeControl destruktor megh√≠vva")

        # Sz√°lak le√°ll√≠t√°sa, ha m√©g futnak
        try:
            self.stop_threads()
            print("[INFO] Sz√°lak le√°ll√≠tva")
        except Exception as e:
            print(f"[WARN] Sz√°lak le√°ll√≠t√°sa sikertelen: {e}")

        # Soros port bez√°r√°sa
        try:
            if self.ser and self.ser.is_open:
                self.ser.close()
                print("[INFO] Soros port bez√°rva")
        except Exception as e:
            print(f"[WARN] Nem siker√ºlt bez√°rni a soros portot: {e}")

    def set_connected(self, connected):
        self.connected = connected
        print(f"Serial port connected - {self.connected}")

    def send_command(self, command, wait_for_completion=False):
        if self.connected:
            if self.lock:
                with self.lock:
                    self.ser.write(command.encode('utf-8'))  # üîÅ EZ!
            else:
                self.ser.write(command.encode('utf-8'))

            time.sleep(0.1)

            if wait_for_completion:
                if self.lock:
                    with self.lock:
                        self.ser.write("M400\n".encode('utf-8'))
                else:
                    self.ser.write("M400\n".encode('utf-8'))
                time.sleep(0.1)
                return self.wait_for_ok(timeout=5)
        else:
            print("send_command - not connected")

    def wait_for_ok(self, timeout=5):
        if not self.ser:
            print("[HIBA] Nincs √©rv√©nyes soros kapcsolat (ser = None)")
            return None

        start_time = time.time()
        while True:
            if self.lock:
                with self.lock:
                    response = self.ser.readline().decode('utf-8', errors='ignore').strip().lower()
            else:
                response = self.ser.readline().decode('utf-8', errors='ignore').strip().lower()

            if "ok" in response:
                # return None
                return response

            if time.time() - start_time > timeout:
                print("[HIBA] G-code v√°lasz timeout (nem j√∂tt 'ok')")
                return None

    def worker_loop(self, q: queue.Queue, name: str):
        if self.connected:
            print(f"[{name}] sz√°l elindult.")
            while self.running:
                try:
                    command = q.get(timeout=1)
                    if command == "STOP":
                        print(f"[{name}] sz√°l le√°ll.")
                        break
                    if name in ("X_motor", "Y_motor"):
                        print(f"[{name}] ‚Üí {command}")
                        self.send_command(command, wait_for_completion=True)
                    elif name == "AUX":
                        # M42 vez√©rl√©s specifikusan
                        if command.startswith("M42"):
                            print(f"[AUX] M42 parancs: {command}")
                            self.send_command(command, wait_for_completion=True)
                    elif name == "CONTROL":
                        print(f"[CONTROL] ‚Üí {command}")
                        self.send_command(command, wait_for_completion=True)
                except queue.Empty:
                    continue
        else:
            print(f"{name} - not connected")

    def start_threads(self):
        if (self.connected):
            """Sz√°lak ind√≠t√°sa: X_motor, Y_motor, AUX (egy√©b funkci√≥k)"""
            # Ne ind√≠ts √∫j sz√°lakat, ha m√°r vannak fut√≥k
            if hasattr(self, 'x_thread') and self.x_thread.is_alive():
                self.log("[WARN] Sz√°lak m√°r futnak, √∫jraind√≠t√°s el≈ëtt le kell √°ll√≠tani ≈ëket.")
                return

            self.x_thread = threading.Thread(target=self.worker_loop, args=(self.x_motor_queue, "X_motor"))
            self.y_thread = threading.Thread(target=self.worker_loop, args=(self.y_motor_queue, "Y_motor"))
            self.aux_thread = threading.Thread(target=self.worker_loop, args=(self.aux_queue, "AUX"))
            self.control_thread = threading.Thread(target=self.worker_loop, args=(self.control_queue, "CONTROL"))

            self.control_thread.start()
            self.x_thread.start()
            self.y_thread.start()
            self.aux_thread.start()
        else:
            print("start_threads - not connected")


    def set_lock(self, lock):
        self.lock = lock


    # üí° Parancsokhoz tartoz√≥ logik√°k
    def set_aux_output(self):
        if(self.connected):
            for _ in range(3):
                self.send_command("M42 P58 S200 \n")
                self.send_command("M42 P58 S0 \n")
        else:
            print("start_threads - not connected")

    def query_endstops(self):
        if self.connected:
            if not self.ser:
                print("[HIBA] Nincs √©rv√©nyes soros kapcsolat (ser = None)")
                return ""

            if self.lock:
                with self.lock:
                    self.ser.write("M119\n".encode('utf-8'))
            else:
                self.ser.write("M119\n".encode('utf-8'))

            time.sleep(0.1)
            if self.lock:
                with self.lock:
                    response = self.ser.read_all().decode('utf-8', errors='ignore')
            else:
                response = self.ser.read_all().decode('utf-8', errors='ignore')

            return response
        else:
            print("[INFO] query_endstops - not connected")
            return ""

    def new_command(self, command: str):
        if self.connected:
            cmd_upper = command.upper().strip()

            if "G1" in cmd_upper or "G0" in cmd_upper:
                if "X" in cmd_upper and "Y" not in cmd_upper:
                    print("[DISPATCH] X_motor_queue ‚Üê", cmd_upper)
                    self.send_to_x(cmd_upper)
                elif "Y" in cmd_upper and "X" not in cmd_upper:
                    print("[DISPATCH] Y_motor_queue ‚Üê", cmd_upper)
                    self.send_to_y(cmd_upper)
                else:
                    print("[DISPATCH] CONTROL_queue (XY kevert vagy m√°s) ‚Üê", cmd_upper)
                    self.send_to_control(cmd_upper)
            elif cmd_upper.startswith("M42"):
                print("[DISPATCH] AUX_queue (M42) ‚Üê", cmd_upper)
                self.send_to_aux(cmd_upper)
            else:
                print("[DISPATCH] CONTROL_queue ‚Üê", cmd_upper)
                self.send_to_control(cmd_upper)
        else:
            print("new_command - not connected")


    def autoconnect(self):
        self.log("[INFO] autoconnect() megh√≠vva")

        # üîÅ Megl√©v≈ë sz√°lak le√°ll√≠t√°sa, ha futnak
        if hasattr(self, 'x_thread') and self.x_thread.is_alive():
            self.log("[INFO] Kor√°bbi sz√°lak le√°ll√≠t√°sa reconnect el≈ëtt...")
            self.stop_threads()
            # √∫jra enged√©lyezni kell a running flaget
            self.running = True


        # YAML-b√≥l pr√≥b√°lunk el≈ësz√∂r csatlakozni
        try:
            settings = config_manager.load_settings()
            preferred_port = settings.get("selected_port", None)
            preferred_baud = settings.get("baud", None)
        except Exception as e:
            self.log(f"[WARN] Nem siker√ºlt bet√∂lteni a be√°ll√≠t√°sokat: {e}")
            preferred_port = preferred_baud = None

        # El≈ësz√∂r pr√≥b√°ljuk az elmentett be√°ll√≠t√°st
        if preferred_port and preferred_baud:
            self.log(f"[INFO] El≈ëz≈ë be√°ll√≠t√°s pr√≥b√°l√°sa: {preferred_port} @ {preferred_baud}")
            try:
                ser = serial.Serial(preferred_port, preferred_baud, timeout=1)
                ser.write(b'\n')
                response = ser.readline()
                if response:
                    self.ser = ser
                    self.set_connected(True)
                    if self.label_status:
                        self.label_status.setText(f"Sikeres csatlakoz√°s: {preferred_port} @ {preferred_baud} baud")
                    self.log(f"[INFO] Sikeres csatlakoz√°s (elmentett): {preferred_port} @ {preferred_baud}")
                    self.start_threads()  # üî• Itt ind√≠tjuk el a sz√°lakat
                    self.start_response_listener()
                    self.load_marlin_config()
                    return
                else:
                    ser.close()
            except Exception as e:
                self.log(f"[HIBA] Elmentett port sikertelen: {e}")

        # Fallback: minden port/baud kipr√≥b√°l√°sa
        self.log("[INFO] Fallback: automatikus keres√©s indul...")
        baud_rates = [250000, 125000, 500000]
        ports = serial.tools.list_ports.comports()

        if not ports:
            if self.label_status:
                self.label_status.setText("Nem tal√°lhat√≥ soros eszk√∂z.")
            self.log("[INFO] Nem tal√°lhat√≥ soros eszk√∂z.")
            return

        for port in ports:
            port_name = port.device
            for baud in baud_rates:
                try:
                    self.log(f"[INFO] Pr√≥b√°lkoz√°s: {port_name} @ {baud}")
                    ser = serial.Serial(port_name, baud, timeout=1)
                    ser.write(b'\n')
                    response = ser.readline()

                    if response:
                        self.ser = ser
                        self.set_connected(True)
                        if self.label_status:
                            self.label_status.setText(f"Sikeres csatlakoz√°s: {port_name} @ {baud} baud")
                        self.log(f"[INFO] Sikeres csatlakoz√°s: {port_name} @ {baud} baud")

                        # üîê Ments√ºk a be√°ll√≠t√°sokat
                        config_manager.update_settings({
                            "selected_port": port_name,
                            "baud": baud
                        })

                        self.start_threads()  # üî• Itt is ind√≠tjuk a sz√°lakat
                        self.start_response_listener()
                        self.load_marlin_config()
                        return
                    else:
                        ser.close()

                except Exception as e:
                    self.log(f"[HIBA] {port_name} @ {baud} - {e}")

        if self.label_status:
            self.label_status.setText("Nem siker√ºlt csatlakozni egyetlen soros porthoz sem.")
        self.log("[INFO] Nem siker√ºlt csatlakozni.")

    def start_response_listener(self):
        if hasattr(self, "response_thread") and self.response_thread.is_alive():
            self.log("[INFO] V√°laszfigyel≈ë sz√°l m√°r fut.")
            return

        self.response_running = True
        self.response_thread = threading.Thread(target=self.response_loop, daemon=True)
        self.response_thread.start()
        self.log("[INFO] V√°laszfigyel≈ë sz√°l elind√≠tva.")

    def response_loop(self):
        while self.response_running and self.connected and self.ser:
            try:
                if self.ser.in_waiting:
                    line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        if line != "ok" :
                            self.log(f"[RESPONSE] {line}")
                else:
                    time.sleep(0.05)
            except Exception as e:
                self.log(f"[HIBA] V√°lasz olvas√°si hiba: {e}")
                break

    def load_marlin_config(self):
        # Bet√∂ltj√ºk √©s alkalmazzuk a be√°ll√≠t√°sokat
        try:
            marlin_config = marlin_config_manager.load_settings()
            self.apply_marlin_settings(marlin_config)
            self.log("[INFO] Marlin be√°ll√≠t√°sok bet√∂ltve √©s alkalmazva.")
        except Exception as e:
            self.log(f"[HIBA] Marlin be√°ll√≠t√°sok bet√∂lt√©se sikertelen: {e}")


    def log(self, message):
        if self.log_widget:
            self.log_widget.append_log(message)
        else:
            print(message)

    # üí¨ K√ºls≈ë parancsk√ºld√©s
    def send_to_x(self, gcode): self.x_motor_queue.put(gcode)
    def send_to_y(self, gcode): self.y_motor_queue.put(gcode)
    def send_to_aux(self, action): self.aux_queue.put(action)
    def send_to_control(self, gcode): self.control_queue.put(gcode)



    def apply_marlin_settings(self, settings: dict):
        if not self.connected:
            self.log("[HIBA] Nem lehet be√°ll√≠t√°sokat alkalmazni ‚Äì nincs kapcsolat.")
            return

        # key: a sz√≥t√°r kulcsa (pl. "motor_current", "feedrate", "steps_per_mm")
        # meta: a kulcshoz tartoz√≥ √©rt√©k, ami egy tov√°bbi sz√≥t√°r
        for key, meta in MARLIN_COMMAND_MAP.items():
            if key not in settings: # Ellen≈ërzi, hogy szerepel-e a settings-ben
                continue

            value = settings[key]
            cmd = meta["cmd"] # kiolvassa az adott konfigur√°ci√≥hoz tartoz√≥ G-code parancs nev√©t a meta sz√≥t√°rb√≥l. PL.: M906

            if "format" in meta: # ellen≈ërzi, hogy a meta nev≈± sz√≥t√°r (dictionary) tartalmazza-e a "format" kulcsot.
                formatted = meta["format"](value) # Egyedi form√°z√°s (pl. G1 F1500 vagy M204 P500 T500)
                self.send_command(f"{cmd} {formatted}\n")
                self.log(f"[GCODE] {cmd} {formatted}")
            # "type": "dict"
            elif meta.get("type") == "dict" and isinstance(value, dict):
                axes = meta.get("axes", "")
                parts = [f"{axis}{value[axis]}" for axis in axes if axis in value] # ha tengelyenk√©nt elt√©r≈ë √©rt√©keket tartalmaz.
                if parts:
                    full = f"{cmd} {' '.join(parts)}"
                    self.send_command(full + "\n")
                    self.log(f"[GCODE] {full}")
            # "type": "value"
            elif meta.get("type") == "value" and isinstance(value, (int, float)):
                # Pl. motor_current ‚Üí M906 X800 Y800 ...
                axes = meta.get("axes", "")
                parts = [f"{axis}{value}" for axis in axes]  # ha minden tengelyre ugyanaz
                if parts:
                    full = f"{cmd} {' '.join(parts)}"
                    self.send_command(full + "\n")
                    self.log(f"[GCODE] {full}")


    def stop_threads(self):
        """Sz√°lak szab√°lyos le√°ll√≠t√°sa √âS kapcsolatbont√°s"""
        self.send_command("M0\n")  # Pause
        self.send_command("M18\n")  # Motor kikapcs

        self.running = False
        self.x_motor_queue.put("STOP")
        self.y_motor_queue.put("STOP")
        self.aux_queue.put("STOP")
        self.control_queue.put("STOP")

        try:
            self.x_thread.join(timeout=2)
            self.y_thread.join(timeout=2)
            self.aux_thread.join(timeout=2)
            self.control_thread.join(timeout=2)
            print("[INFO] Sz√°lak sikeresen le√°lltak.")
        except Exception as e:
            print(f"[HIBA] Sz√°lak le√°ll√≠t√°sa k√∂zben hiba t√∂rt√©nt: {e}")

        # --- üîå Kapcsolat bont√°s ---
        try:
            if self.ser and self.ser.is_open:
                self.ser.close()
                print("[INFO] Soros port szab√°lyosan bez√°rva.")
        except Exception as e:
            print(f"[HIBA] Port lez√°r√°sa nem siker√ºlt: {e}")

        self.ser = None
        self.set_connected(False)

        self.response_running = False
        if hasattr(self, "response_thread"):
            self.response_thread.join(timeout=2)
            self.log("[INFO] V√°laszfigyel≈ë sz√°l le√°ll√≠tva.")

