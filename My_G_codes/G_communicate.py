import threading
import time
import queue
import serial  # pyserial
import serial.tools.list_ports

class GCodeControl:
    def __init__(self, lock=None):
        self.lock = lock
        self.ser = None
        self.lock = lock
        self.connected = False
        self.label_status = None  # ezt k√≠v√ºlr≈ël lehet be√°ll√≠tani (pl. a GUI-b√≥l)
        self.log_widget = None  # Ezt majd k√≠v√ºlr≈ël be√°ll√≠tod a MainWindow-ban


        # Parancs sorok minden sz√°lhoz
        self.x_motor_queue = queue.Queue()
        self.y_motor_queue = queue.Queue()
        self.aux_queue = queue.Queue()

        self.running = True

    def __del__(self):
        print("[INFO] GCodeControl destruktor megh√≠vva")

        # Sz√°lak le√°ll√≠t√°sa, ha m√©g futnak
        try:
            self.stop_threads()
            print("[INFO] Sz√°lak le√°ll√≠tva")
        except Exception as e:
            print(f"[WARN] Sz√°lak le√°ll√≠t√°sa sikertelen: {e}")

        # Soros port bez√°r√°sa
        try:
            if self.ser and self.ser.is_open:
                self.ser.close()
                print("[INFO] Soros port bez√°rva")
        except Exception as e:
            print(f"[WARN] Nem siker√ºlt bez√°rni a soros portot: {e}")

    def set_connected(self, connected):
        self.connected = connected
        print(f"Serial port connected - {self.connected}")

    def send_command(self, command, wait_for_completion=False):
        if self.connected:
            if self.lock:
                with self.lock:
                    self.ser.write(command.encode('utf-8'))  # üîÅ EZ!
            else:
                self.ser.write(command.encode('utf-8'))

            time.sleep(0.1)

            if wait_for_completion:
                if self.lock:
                    with self.lock:
                        self.ser.write("M400\n".encode('utf-8'))
                else:
                    self.ser.write("M400\n".encode('utf-8'))
                time.sleep(0.1)
                return self.wait_for_ok(timeout=5)
        else:
            print("send_command - not connected")

    def wait_for_ok(self, timeout=5):
        if not self.ser:
            print("[HIBA] Nincs √©rv√©nyes soros kapcsolat (ser = None)")
            return None

        start_time = time.time()
        while True:
            if self.lock:
                with self.lock:
                    response = self.ser.readline().decode('utf-8', errors='ignore').strip().lower()
            else:
                response = self.ser.readline().decode('utf-8', errors='ignore').strip().lower()

            if "ok" in response:
                return response

            if time.time() - start_time > timeout:
                print("[HIBA] G-code v√°lasz timeout (nem j√∂tt 'ok')")
                return None

    def worker_loop(self, q: queue.Queue, name: str):
        """√Åltal√°nos sz√°lkezel≈ë, ami feldolgozza a queue-ban √©rkez≈ë parancsokat"""
        if(self.connected):
            print(f"[{name}] sz√°l elindult.")
            while self.running:
                try:
                    command = q.get(timeout=1)
                    if command == "STOP":
                        print(f"[{name}] sz√°l le√°ll.")
                        break
                    if name in ("X_motor", "Y_motor"):
                        print(f"[{name}] ‚Üí {command}")
                        self.send_command(command, wait_for_completion=True)
                    else:
                        if command == "set_aux":
                            self.set_aux_output()
                        elif command == "get_info":
                            info = self.query_endstops()
                            print(f"[AUX] Endstop info:\n{info}")
                        elif command == "set_something":
                            self.send_command("M42 P5 S255\n")  # P√©lda
                except queue.Empty:
                    continue
        else:
            print("worker_loop - not connected")

    def start_threads(self):
        if (self.connected):
            """Sz√°lak ind√≠t√°sa: X_motor, Y_motor, AUX (egy√©b funkci√≥k)"""
            self.x_thread = threading.Thread(target=self.worker_loop, args=(self.x_motor_queue, "X_motor"))
            self.y_thread = threading.Thread(target=self.worker_loop, args=(self.y_motor_queue, "Y_motor"))
            self.aux_thread = threading.Thread(target=self.worker_loop, args=(self.aux_queue, "AUX"))

            self.x_thread.start()
            self.y_thread.start()
            self.aux_thread.start()
        else:
            print("start_threads - not connected")


    def set_lock(self, lock):
        self.lock = lock

    def stop_threads(self):
        """Sz√°lak szab√°lyos le√°ll√≠t√°sa"""
        self.running = False
        self.x_motor_queue.put("STOP")
        self.y_motor_queue.put("STOP")
        self.aux_queue.put("STOP")

        try:
            self.x_thread.join(timeout=2)
            self.y_thread.join(timeout=2)
            self.aux_thread.join(timeout=2)
            print("[INFO] Sz√°lak sikeresen le√°lltak.")
        except Exception as e:
            print(f"[HIBA] Sz√°lak le√°ll√≠t√°sa k√∂zben hiba t√∂rt√©nt: {e}")

    # üí° Parancsokhoz tartoz√≥ logik√°k
    def set_aux_output(self):
        if(self.connected):
            for _ in range(3):
                self.send_command("M42 P58 S200 \n")
                self.send_command("M42 P58 S0 \n")
        else:
            print("start_threads - not connected")

    def query_endstops(self):
        if self.connected:
            if not self.ser:
                print("[HIBA] Nincs √©rv√©nyes soros kapcsolat (ser = None)")
                return ""

            if self.lock:
                with self.lock:
                    self.ser.write("M119\n".encode('utf-8'))
            else:
                self.ser.write("M119\n".encode('utf-8'))

            time.sleep(0.1)
            if self.lock:
                with self.lock:
                    response = self.ser.read_all().decode('utf-8', errors='ignore')
            else:
                response = self.ser.read_all().decode('utf-8', errors='ignore')

            return response
        else:
            print("[INFO] query_endstops - not connected")
            return ""

    def new_command(self, command: str):
        if (self.connected):
            # √öj G-k√≥d fogad√°sa: ir√°ny szerint sorba √°ll√≠tja a megfelel≈ë queue-ba.
            cmd_upper = command.upper()

            # El≈ëfeldolgoz√°s: elt√°vol√≠tjuk a kommenteket, √ºres helyeket
            cmd_clean = cmd_upper.strip()

            if "G1" in cmd_clean or "G0" in cmd_clean:
                if "X" in cmd_clean and "Y" not in cmd_clean:
                    print("[DISPATCH] X_motor_queue ‚Üê", cmd_clean)
                    self.send_to_x(cmd_clean)
                elif "Y" in cmd_clean and "X" not in cmd_clean:
                    print("[DISPATCH] Y_motor_queue ‚Üê", cmd_clean)
                    self.send_to_y(cmd_clean)
                else:
                    print("[DISPATCH] AUX_queue ‚Üê", cmd_clean)
                    self.send_aux(cmd_clean)
            else:
                print("[DISPATCH] AUX_queue (nem mozg√°sparancs) ‚Üê", cmd_clean)
                self.send_aux(cmd_clean)
        else:
            print("start_threads - not connected")

    def autoconnect(self):
        self.log("[INFO] autoconnect() megh√≠vva")

        # YAML-b√≥l pr√≥b√°lunk el≈ësz√∂r csatlakozni
        try:
            from file_managers import config_manager
            settings = config_manager.load_settings()
            preferred_port = settings.get("selected_port", None)
            preferred_baud = settings.get("baud", None)
        except Exception as e:
            self.log(f"[WARN] Nem siker√ºlt bet√∂lteni a be√°ll√≠t√°sokat: {e}")
            preferred_port = preferred_baud = None

        # El≈ësz√∂r pr√≥b√°ljuk az elmentett be√°ll√≠t√°st
        if preferred_port and preferred_baud:
            self.log(f"[INFO] El≈ëz≈ë be√°ll√≠t√°s pr√≥b√°l√°sa: {preferred_port} @ {preferred_baud}")
            try:
                ser = serial.Serial(preferred_port, preferred_baud, timeout=1)
                ser.write(b'\n')
                response = ser.readline()
                if response:
                    self.ser = ser
                    self.set_connected(True)
                    if self.label_status:
                        self.label_status.setText(f"Sikeres csatlakoz√°s: {preferred_port} @ {preferred_baud} baud")
                    self.log(f"[INFO] Sikeres csatlakoz√°s (elmentett): {preferred_port} @ {preferred_baud}")
                    self.start_threads()  # üî• Itt ind√≠tjuk el a sz√°lakat
                    return
                else:
                    ser.close()
            except Exception as e:
                self.log(f"[HIBA] Elmentett port sikertelen: {e}")

        # Fallback: minden port/baud kipr√≥b√°l√°sa
        self.log("[INFO] Fallback: automatikus keres√©s indul...")
        baud_rates = [250000, 125000, 500000]
        ports = serial.tools.list_ports.comports()

        if not ports:
            if self.label_status:
                self.label_status.setText("Nem tal√°lhat√≥ soros eszk√∂z.")
            self.log("[INFO] Nem tal√°lhat√≥ soros eszk√∂z.")
            return

        for port in ports:
            port_name = port.device
            for baud in baud_rates:
                try:
                    self.log(f"[INFO] Pr√≥b√°lkoz√°s: {port_name} @ {baud}")
                    ser = serial.Serial(port_name, baud, timeout=1)
                    ser.write(b'\n')
                    response = ser.readline()

                    if response:
                        self.ser = ser
                        self.set_connected(True)
                        if self.label_status:
                            self.label_status.setText(f"Sikeres csatlakoz√°s: {port_name} @ {baud} baud")
                        self.log(f"[INFO] Sikeres csatlakoz√°s: {port_name} @ {baud} baud")

                        # üîê Ments√ºk a be√°ll√≠t√°sokat
                        config_manager.update_settings({
                            "selected_port": port_name,
                            "baud": baud
                        })

                        self.start_threads()  # üî• Itt is ind√≠tjuk a sz√°lakat
                        return
                    else:
                        ser.close()

                except Exception as e:
                    self.log(f"[HIBA] {port_name} @ {baud} - {e}")

        if self.label_status:
            self.label_status.setText("Nem siker√ºlt csatlakozni egyetlen soros porthoz sem.")
        self.log("[INFO] Nem siker√ºlt csatlakozni.")

    def log(self, message):
        if self.log_widget:
            self.log_widget.append_log(message)
        else:
            print(message)

    # üí¨ K√ºls≈ë parancsk√ºld√©s
    def send_to_x(self, gcode): self.x_motor_queue.put(gcode)
    def send_to_y(self, gcode): self.y_motor_queue.put(gcode)
    def send_aux(self, action): self.aux_queue.put(action)

